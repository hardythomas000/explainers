<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>microGPT — How It Works</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0c0a0f;
  --bg-surface: #16131c;
  --bg-interactive: #1e1a26;
  --text: #f0ece4;
  --text-secondary: #9e96a8;
  --text-dim: #5a5264;
  --border: #2a2435;
  --accent: #f0a848;
  --accent2: #e85d9a;
  --accent3: #7deba0;
  --accent4: #8cb4ff;
  --accent-glow: rgba(240, 168, 72, 0.15);
  --font: 'Inter', -apple-system, system-ui, sans-serif;
  --mono: 'JetBrains Mono', 'SF Mono', monospace;
}

html { scroll-behavior: smooth; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  line-height: 1.6;
  overflow-x: hidden;
}

/* ============ PROGRESS BAR ============ */
.progress-bar {
  position: fixed; top: 0; left: 0; height: 2px;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  z-index: 100; width: 0%; transition: width 0.1s;
}

/* ============ NAV DOTS ============ */
.nav-dots {
  position: fixed; right: 16px; top: 50%; transform: translateY(-50%);
  display: flex; flex-direction: column; gap: 12px; z-index: 50;
}
.nav-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--text-dim); border: none; cursor: pointer;
  transition: all 0.3s; position: relative;
}
.nav-dot.active { background: var(--accent); box-shadow: 0 0 8px var(--accent); }
.nav-dot::before {
  content: attr(data-label); position: absolute; right: 20px; top: 50%;
  transform: translateY(-50%); white-space: nowrap; font-size: 0.65em;
  color: var(--text-secondary); opacity: 0; transition: opacity 0.2s;
  pointer-events: none; background: var(--bg-surface); padding: 2px 8px;
  border-radius: 4px; border: 1px solid var(--border);
}
.nav-dot:hover::before { opacity: 1; }

/* ============ LAYOUT ============ */
.chapter {
  min-height: 100vh; padding: 100px 24px;
  display: flex; justify-content: center;
  border-bottom: 1px solid var(--border);
}
.col-wide { max-width: 720px; width: 100%; }

.chapter-label {
  font-size: 0.65em; font-weight: 700; text-transform: uppercase;
  letter-spacing: 3px; color: var(--accent); margin-bottom: 16px;
}
.chapter h2 {
  font-size: clamp(1.8em, 4vw, 2.6em); font-weight: 900;
  letter-spacing: -0.03em; line-height: 1.1; margin-bottom: 20px;
}
.lead {
  font-size: 1.05em; color: var(--text-secondary);
  line-height: 1.7; margin-bottom: 32px;
}
.highlight {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* ============ HERO ============ */
.hero {
  min-height: 100vh; display: flex; flex-direction: column;
  align-items: flex-start; justify-content: center;
  padding: 60px 24px; max-width: 720px; margin: 0 auto;
}
.hero-badge {
  display: inline-flex; align-items: center; gap: 8px;
  font-size: 0.7em; font-weight: 600; letter-spacing: 1px;
  color: var(--text-secondary); margin-bottom: 20px;
  text-transform: uppercase;
}
.hero-badge-dot {
  width: 6px; height: 6px; border-radius: 50%;
  background: var(--accent3); animation: pulse 2s infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 1; } 50% { opacity: 0.4; }
}
.hero h1 {
  font-size: clamp(2.2em, 6vw, 3.5em); font-weight: 900;
  letter-spacing: -0.04em; line-height: 1.08; margin-bottom: 16px;
}
.hero-sub {
  font-size: 1.1em; color: var(--text-secondary);
  line-height: 1.7; margin-bottom: 40px; max-width: 520px;
}
.hero-stats {
  display: flex; gap: 32px; flex-wrap: wrap;
}
.hero-stat-val {
  font-size: 1.6em; font-weight: 800; color: var(--text);
  font-family: var(--mono);
}
.hero-stat-label {
  font-size: 0.7em; color: var(--text-dim);
  text-transform: uppercase; letter-spacing: 1px;
}

/* ============ HERO BACKGROUND ============ */
.hero-bg {
  position: fixed; inset: 0; z-index: -1;
  background: radial-gradient(ellipse 60% 40% at 50% 30%, rgba(240,168,72,0.06) 0%, transparent 70%);
}
.hero-grid {
  position: fixed; inset: 0; z-index: -1;
  background-image:
    linear-gradient(rgba(42,36,53,0.5) 1px, transparent 1px),
    linear-gradient(90deg, rgba(42,36,53,0.5) 1px, transparent 1px);
  background-size: 60px 60px;
  mask-image: radial-gradient(ellipse 70% 50% at 50% 50%, black 20%, transparent 70%);
  -webkit-mask-image: radial-gradient(ellipse 70% 50% at 50% 50%, black 20%, transparent 70%);
  opacity: 0.4;
}

/* ============ CALLOUT ============ */
.callout {
  background: var(--bg-surface); border-left: 3px solid var(--accent);
  padding: 20px 24px; border-radius: 0 12px 12px 0;
  font-size: 0.92em; line-height: 1.7; color: var(--text-secondary);
  margin: 24px 0;
}
.callout strong { color: var(--text); }

/* ============ COMPARE CARDS ============ */
.compare-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 24px 0; }
.compare-card {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 14px; padding: 24px; position: relative;
}
.compare-card .badge {
  font-size: 0.6em; font-weight: 700; text-transform: uppercase;
  letter-spacing: 2px; margin-bottom: 8px; display: block;
}
.compare-card.bad .badge { color: var(--accent2); }
.compare-card.good .badge { color: var(--accent3); }
.compare-card h3 { font-size: 1.1em; margin-bottom: 8px; }
.compare-card p { font-size: 0.82em; color: var(--text-secondary); line-height: 1.6; }
@media (max-width: 600px) { .compare-row { grid-template-columns: 1fr; } }

/* ============ INTERACTIVE CODE STEPPER ============ */
.code-explorer {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 16px; overflow: hidden; margin: 24px 0;
}
.code-explorer-header {
  padding: 12px 20px; border-bottom: 1px solid var(--border);
  display: flex; align-items: center; gap: 12px;
  font-size: 0.75em; color: var(--text-dim);
}
.code-explorer-header .filename {
  font-family: var(--mono); color: var(--text-secondary);
}
.code-explorer-header .controls {
  margin-left: auto; display: flex; gap: 6px;
}
.code-explorer-header .controls button {
  background: var(--bg-interactive); border: 1px solid var(--border);
  color: var(--text-secondary); padding: 4px 12px; border-radius: 6px;
  font-size: 11px; cursor: pointer; font-family: var(--mono);
  transition: all 0.2s;
}
.code-explorer-header .controls button:hover {
  border-color: var(--accent); color: var(--accent);
}
.code-explorer-header .controls button.playing {
  border-color: var(--accent3); color: var(--accent3);
}
.code-body {
  display: grid; grid-template-columns: 1fr 300px;
  max-height: 500px;
}
.code-lines {
  overflow-y: auto; padding: 12px 0; font-family: var(--mono);
  font-size: 12px; line-height: 1.8; counter-reset: line;
}
.code-lines::-webkit-scrollbar { width: 4px; }
.code-lines::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.code-line {
  padding: 0 16px 0 48px; position: relative; cursor: pointer;
  transition: background 0.15s; white-space: pre; min-height: 1.8em;
}
.code-line::before {
  content: attr(data-n); position: absolute; left: 8px; width: 32px;
  text-align: right; color: var(--text-dim); font-size: 10px;
}
.code-line:hover { background: rgba(240,168,72,0.05); }
.code-line.active {
  background: rgba(240,168,72,0.12);
  border-left: 2px solid var(--accent);
}
.code-line.active::before { color: var(--accent); }

/* Syntax colors */
.syn-kw { color: #e85d9a; }
.syn-fn { color: #f0a848; }
.syn-str { color: #7deba0; }
.syn-num { color: #e8c560; }
.syn-cmt { color: #5a5264; font-style: italic; }
.syn-op { color: #e85d9a; }
.syn-cls { color: #ffa657; }
.syn-self { color: #e85d9a; font-style: italic; }
.syn-dec { color: #7deba0; }

/* Explanation panel */
.code-explain {
  border-left: 1px solid var(--border); padding: 16px 20px;
  overflow-y: auto; font-size: 0.85em; line-height: 1.7;
  color: var(--text-secondary);
}
.code-explain::-webkit-scrollbar { width: 4px; }
.code-explain::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.code-explain h4 {
  font-size: 0.85em; font-weight: 700; color: var(--accent);
  text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;
}
.code-explain .tag {
  display: inline-block; font-size: 0.65em; font-weight: 700;
  padding: 2px 8px; border-radius: 4px; margin-right: 6px;
  text-transform: uppercase; letter-spacing: 1px;
}
.tag-data { background: #ffd86622; color: var(--accent4); }
.tag-math { background: #6c8aff22; color: var(--accent); }
.tag-arch { background: #ff6ac122; color: var(--accent2); }
.tag-train { background: #69ff9422; color: var(--accent3); }
@media (max-width: 700px) {
  .code-body { grid-template-columns: 1fr; max-height: none; }
  .code-explain { border-left: none; border-top: 1px solid var(--border); max-height: 200px; }
}

/* ============ INTERACTIVE DEMOS ============ */
.demo-box {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 16px; padding: 24px; margin: 24px 0;
}
.demo-box h4 {
  font-size: 0.8em; font-weight: 700; color: var(--accent);
  text-transform: uppercase; letter-spacing: 1px; margin-bottom: 16px;
}

/* Computation graph */
.comp-graph {
  width: 100%; height: 300px; position: relative;
  background: var(--bg); border-radius: 12px; border: 1px solid var(--border);
  overflow: hidden;
}
.comp-graph canvas { width: 100%; height: 100%; }

/* Attention heatmap */
.attn-demo { display: flex; flex-direction: column; gap: 16px; }
.attn-grid {
  display: grid; gap: 2px; width: fit-content; margin: 0 auto;
}
.attn-cell {
  width: 36px; height: 36px; border-radius: 4px;
  display: flex; align-items: center; justify-content: center;
  font-family: var(--mono); font-size: 9px; color: var(--text);
  transition: all 0.3s;
}
.attn-labels {
  display: flex; gap: 2px; justify-content: center;
}
.attn-label {
  width: 36px; text-align: center; font-family: var(--mono);
  font-size: 10px; color: var(--text-dim);
}
.attn-controls {
  display: flex; gap: 8px; align-items: center; justify-content: center;
  font-size: 0.8em;
}
.attn-controls button {
  background: var(--bg-interactive); border: 1px solid var(--border);
  color: var(--text-secondary); padding: 6px 16px; border-radius: 8px;
  font-size: 12px; cursor: pointer; font-family: var(--font);
  transition: all 0.2s;
}
.attn-controls button:hover { border-color: var(--accent); color: var(--accent); }

/* Token probability demo */
.token-probs {
  display: flex; flex-direction: column; gap: 6px;
}
.token-prob-row {
  display: flex; align-items: center; gap: 10px;
}
.token-prob-char {
  font-family: var(--mono); font-size: 1.1em; font-weight: 700;
  width: 24px; text-align: center; color: var(--text);
}
.token-prob-bar-wrap {
  flex: 1; height: 20px; background: var(--bg); border-radius: 4px;
  overflow: hidden; position: relative;
}
.token-prob-bar {
  height: 100%; border-radius: 4px; transition: width 0.5s ease;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
}
.token-prob-val {
  font-family: var(--mono); font-size: 0.75em; color: var(--text-dim);
  width: 48px; text-align: right;
}

/* Temperature slider */
.temp-control {
  display: flex; align-items: center; gap: 12px; margin: 16px 0;
  font-size: 0.85em;
}
.temp-control input[type="range"] {
  flex: 1; accent-color: var(--accent);
}
.temp-control .val {
  font-family: var(--mono); color: var(--accent);
  min-width: 36px; text-align: right;
}

/* Training loss chart */
.loss-chart {
  width: 100%; height: 200px; position: relative;
  background: var(--bg); border-radius: 12px; border: 1px solid var(--border);
}
.loss-chart canvas { width: 100%; height: 100%; }

/* Embedding visualization */
.embed-viz {
  width: 100%; height: 260px; position: relative;
  background: var(--bg); border-radius: 12px; border: 1px solid var(--border);
}
.embed-viz canvas { width: 100%; height: 100%; }

/* ============ PIPELINE ============ */
.pipeline {
  display: flex; gap: 0; align-items: stretch; margin: 24px 0;
  overflow-x: auto; padding-bottom: 8px;
}
.pipeline::-webkit-scrollbar { height: 4px; }
.pipeline::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.pipe-stage {
  flex: 1; min-width: 120px; background: var(--bg-surface);
  border: 1px solid var(--border); padding: 16px;
  position: relative; text-align: center;
}
.pipe-stage:first-child { border-radius: 12px 0 0 12px; }
.pipe-stage:last-child { border-radius: 0 12px 12px 0; }
.pipe-stage::after {
  content: ''; position: absolute; right: -8px; top: 50%;
  transform: translateY(-50%); width: 0; height: 0;
  border: 6px solid transparent; border-left-color: var(--accent);
  z-index: 2;
}
.pipe-stage:last-child::after { display: none; }
.pipe-stage .pipe-icon { font-size: 1.4em; margin-bottom: 6px; }
.pipe-stage .pipe-label {
  font-size: 0.7em; font-weight: 700; text-transform: uppercase;
  letter-spacing: 1px; color: var(--accent); margin-bottom: 4px;
}
.pipe-stage .pipe-desc {
  font-size: 0.72em; color: var(--text-dim); line-height: 1.5;
}

/* ============ FOOTER ============ */
.footer {
  padding: 48px 24px; text-align: center;
  color: var(--text-dim); font-size: 0.75em;
}
.footer a { color: var(--text-secondary); text-decoration: none; }
.footer a:hover { color: var(--accent); }

/* ============ REVEAL ANIMATION ============ */
.reveal {
  opacity: 0; transform: translateY(30px);
  transition: opacity 0.6s cubic-bezier(0.16,1,0.3,1), transform 0.6s cubic-bezier(0.16,1,0.3,1);
}
.reveal.visible { opacity: 1; transform: translateY(0); }
.delay-1 { transition-delay: 0.1s; }
.delay-2 { transition-delay: 0.2s; }
.delay-3 { transition-delay: 0.3s; }
.delay-4 { transition-delay: 0.4s; }
</style>
</head>
<body>

<div class="progress-bar" id="progressBar"></div>
<div class="hero-bg"></div>
<div class="hero-grid"></div>

<nav class="nav-dots" id="navDots">
  <button class="nav-dot active" data-label="Top" onclick="scrollToChapter(0)"></button>
  <button class="nav-dot" data-label="The Idea" onclick="scrollToChapter(1)"></button>
  <button class="nav-dot" data-label="Tokenizer" onclick="scrollToChapter(2)"></button>
  <button class="nav-dot" data-label="Autograd" onclick="scrollToChapter(3)"></button>
  <button class="nav-dot" data-label="Architecture" onclick="scrollToChapter(4)"></button>
  <button class="nav-dot" data-label="Training" onclick="scrollToChapter(5)"></button>
  <button class="nav-dot" data-label="Inference" onclick="scrollToChapter(6)"></button>
</nav>

<!-- ===================== HERO ===================== -->
<section class="chapter" id="ch0" style="border-bottom: none; min-height: 100vh;">
  <div class="hero">
    <div class="hero-badge reveal">
      <span class="hero-badge-dot"></span>
      Andrej Karpathy's microGPT &middot; Explainer
    </div>
    <h1 class="reveal delay-1">A complete GPT<br>in <span class="highlight">pure Python.</span></h1>
    <p class="hero-sub reveal delay-2">
      No libraries. No frameworks. Just the actual algorithm behind ChatGPT, Claude, and every other AI chatbot, written from scratch in about 100 lines. This page walks through how it works.
    </p>
    <div class="hero-stats reveal delay-3">
      <div class="hero-stat">
        <div class="hero-stat-val">~4K</div>
        <div class="hero-stat-label">Parameters</div>
      </div>
      <div class="hero-stat">
        <div class="hero-stat-val">0</div>
        <div class="hero-stat-label">Dependencies</div>
      </div>
      <div class="hero-stat">
        <div class="hero-stat-val">~100</div>
        <div class="hero-stat-label">Lines</div>
      </div>
      <div class="hero-stat">
        <div class="hero-stat-val">1</div>
        <div class="hero-stat-label">File</div>
      </div>
    </div>
  </div>
</section>

<!-- ===================== CH1: THE IDEA ===================== -->
<section class="chapter" id="ch1">
  <div class="col-wide">
    <div class="chapter-label reveal">01 &mdash; The Idea</div>
    <h2 class="reveal delay-1">Everything else<br>is just <span class="highlight">efficiency</span></h2>
    <p class="lead reveal delay-2">
      ChatGPT, Claude, Gemini. They seem impossibly complex. Billions of numbers, trained on the entire internet. But the actual recipe? It fits on one page. Andrej Karpathy (one of the founders of OpenAI) took that recipe and wrote it from scratch, showing every step, with nothing hidden behind libraries.
    </p>

    <div class="compare-row reveal delay-3">
      <div class="compare-card bad">
        <span class="badge">GPT-4 Scale</span>
        <h3>Industrial scale</h3>
        <p>Warehouses full of specialised hardware, months of training, more text than you could read in a thousand lifetimes, and millions of lines of engineering code to hold it all together.</p>
      </div>
      <div class="compare-card good">
        <span class="badge">microGPT</span>
        <h3>Same recipe</h3>
        <p>One file. Trains on a list of baby names. Learns to make up new ones. Uses the exact same steps as the big models, just tiny. Like building a working jet engine the size of a coffee cup.</p>
      </div>
    </div>

    <div class="pipeline reveal delay-4">
      <div class="pipe-stage">
        <div class="pipe-label">Tokenize</div>
        <div class="pipe-desc">Turn letters into numbers</div>
      </div>
      <div class="pipe-stage">
        <div class="pipe-label">Embed</div>
        <div class="pipe-desc">Give each number a meaning</div>
      </div>
      <div class="pipe-stage">
        <div class="pipe-label">Attend</div>
        <div class="pipe-desc">Let letters look at each other</div>
      </div>
      <div class="pipe-stage">
        <div class="pipe-label">Think</div>
        <div class="pipe-desc">Crunch the numbers</div>
      </div>
      <div class="pipe-stage">
        <div class="pipe-label">Predict</div>
        <div class="pipe-desc">Guess the next letter</div>
      </div>
      <div class="pipe-stage">
        <div class="pipe-label">Learn</div>
        <div class="pipe-desc">Fix mistakes, try again</div>
      </div>
    </div>
  </div>
</section>

<!-- ===================== CH2: TOKENIZER ===================== -->
<section class="chapter" id="ch2">
  <div class="col-wide">
    <div class="chapter-label reveal">02 &mdash; The Tokenizer</div>
    <h2 class="reveal delay-1">Letters in,<br><span class="highlight">numbers</span> out</h2>
    <p class="lead reveal delay-2">
      Computers can't read letters. They only work with numbers. So the first step is converting each letter into a number. The letter "a" might become 0, "b" becomes 1, and so on. There's also a special marker called BOS that tells the model "a name starts here" and "a name ends here."
    </p>

    <div class="demo-box reveal delay-3" id="tokenizerDemo">
      <h4>Interactive Tokenizer</h4>
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:16px;flex-wrap:wrap;">
        <span style="font-size:0.8em;color:var(--text-dim);">Type a name:</span>
        <input id="tokInput" type="text" value="hardy" maxlength="8" spellcheck="false"
          style="background:var(--bg);border:1px solid var(--border);color:var(--text);padding:8px 14px;
          border-radius:8px;font-family:var(--mono);font-size:1em;width:140px;outline:none;"
        >
      </div>
      <div id="tokOutput" style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:16px;"></div>
      <div id="tokSequence" style="font-family:var(--mono);font-size:0.8em;color:var(--text-dim);"></div>
    </div>

    <div class="callout reveal delay-4">
      <strong>Why single letters?</strong> Real AI chatbots chop words into chunks (like "un" + "believ" + "able") because it's faster. microGPT keeps it dead simple: one letter = one token. The entire vocabulary is just the alphabet plus a start/end marker. About 28 tokens total.
    </div>
  </div>
</section>

<!-- ===================== CH3: AUTOGRAD ===================== -->
<section class="chapter" id="ch3">
  <div class="col-wide">
    <div class="chapter-label reveal">03 &mdash; The Autograd</div>
    <h2 class="reveal delay-1">Teaching the network<br>to <span class="highlight">learn</span></h2>
    <p class="lead reveal delay-2">
      This is how the model learns from its mistakes. Every calculation the model does is recorded, like breadcrumbs through a maze. When the model gets something wrong, it traces those breadcrumbs backwards to figure out which numbers caused the mistake, and how much each one contributed. Then it adjusts them. That's it. That's learning.
    </p>

    <div class="demo-box reveal delay-3" id="autogradDemo">
      <h4>Computation Graph</h4>
      <p style="font-size:0.8em;color:var(--text-dim);margin-bottom:12px;">
        Numbers flow left to right to make a prediction (gold). When the prediction is wrong, blame flows right to left (pink) to figure out what to fix. Click the buttons to see each direction.
      </p>
      <div class="comp-graph" id="compGraph">
        <canvas id="compCanvas"></canvas>
      </div>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:center;">
        <button onclick="runAutograd('forward')" style="background:var(--bg-interactive);border:1px solid var(--border);color:var(--accent);padding:6px 20px;border-radius:8px;cursor:pointer;font-family:var(--font);font-size:12px;">Forward</button>
        <button onclick="runAutograd('backward')" style="background:var(--bg-interactive);border:1px solid var(--border);color:var(--accent2);padding:6px 20px;border-radius:8px;cursor:pointer;font-family:var(--font);font-size:12px;">Backward</button>
        <button onclick="runAutograd('reset')" style="background:var(--bg-interactive);border:1px solid var(--border);color:var(--text-dim);padding:6px 20px;border-radius:8px;cursor:pointer;font-family:var(--font);font-size:12px;">Reset</button>
      </div>
    </div>

    <div class="callout reveal delay-4" style="border-left-color: var(--accent2);">
      <strong>This is what PyTorch does.</strong> When researchers build AI models, they use a library called PyTorch that does this exact thing, but on graphics cards processing millions of numbers at once. microGPT does it one number at a time so you can see every step. Way too slow for real use, but perfect for understanding.
    </div>
  </div>
</section>

<!-- ===================== CH4: ARCHITECTURE ===================== -->
<section class="chapter" id="ch4">
  <div class="col-wide">
    <div class="chapter-label reveal">04 &mdash; The Architecture</div>
    <h2 class="reveal delay-1">Attention is<br><span class="highlight">all you need</span></h2>
    <p class="lead reveal delay-2">
      Here's the core idea: when the model is trying to guess the next letter, it doesn't just look at the last letter. It looks at <em>all</em> the letters so far and decides which ones matter most. Predicting what comes after "joh"? The "j" matters a lot (probably "john"). That's attention. The model has 4 separate "attention heads" that each learn to focus on different patterns.
    </p>

    <div class="demo-box reveal delay-3" id="attnDemo">
      <h4>Attention Heatmap</h4>
      <p style="font-size:0.8em;color:var(--text-dim);margin-bottom:12px;">
        Each cell shows how much one letter is paying attention to another. Brighter = paying more attention. The dark triangle means a letter can only look backwards, never at future letters. Click "Randomize" to see different patterns.
      </p>
      <div class="attn-demo">
        <div id="attnLabelsTop" class="attn-labels"></div>
        <div style="display:flex;gap:2px;">
          <div id="attnLabelsLeft" style="display:flex;flex-direction:column;gap:2px;justify-content:center;"></div>
          <div id="attnGrid" class="attn-grid"></div>
        </div>
        <div class="attn-controls">
          <span style="color:var(--text-dim);font-size:0.85em;">Head:</span>
          <button onclick="setAttnHead(0)" class="attn-head-btn" data-h="0">1</button>
          <button onclick="setAttnHead(1)" class="attn-head-btn" data-h="1">2</button>
          <button onclick="setAttnHead(2)" class="attn-head-btn" data-h="2">3</button>
          <button onclick="setAttnHead(3)" class="attn-head-btn" data-h="3">4</button>
          <button onclick="randomizeAttn()" style="margin-left:8px;">Randomize</button>
        </div>
      </div>
    </div>

    <div class="callout reveal delay-4" style="border-left-color: var(--accent3);">
      <strong>Simplified on purpose.</strong> microGPT uses slightly simpler versions of some building blocks compared to the original GPT-2, but the simplifications actually match what newer models like LLaMA use. The core idea is identical: attention + a simple neural network, stacked in layers.
    </div>
  </div>
</section>

<!-- ===================== CH5: TRAINING ===================== -->
<section class="chapter" id="ch5">
  <div class="col-wide">
    <div class="chapter-label reveal">05 &mdash; The Training Loop</div>
    <h2 class="reveal delay-1">500 steps to<br><span class="highlight">learn names</span></h2>
    <p class="lead reveal delay-2">
      Training is just a loop. Pick a name from the list. Show it to the model letter by letter. After each letter, the model guesses the next one. If it's wrong, trace the blame backwards (that's the autograd from earlier), then nudge every number in the model slightly to make it less wrong next time. Do this 500 times and the model gets pretty good at guessing what comes next in a name.
    </p>

    <div class="demo-box reveal delay-3" id="trainDemo">
      <h4>Training Simulation</h4>
      <p style="font-size:0.8em;color:var(--text-dim);margin-bottom:12px;">
        The "loss" measures how wrong the model's guesses are. Watch it drop as the model learns. Lower = smarter.
      </p>
      <div class="loss-chart" id="lossChart">
        <canvas id="lossCanvas"></canvas>
      </div>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:center;align-items:center;">
        <button id="trainBtn" onclick="startTraining()" style="background:var(--bg-interactive);border:1px solid var(--border);color:var(--accent3);padding:6px 20px;border-radius:8px;cursor:pointer;font-family:var(--font);font-size:12px;">Train</button>
        <span id="trainStatus" style="font-family:var(--mono);font-size:0.8em;color:var(--text-dim);">Ready</span>
      </div>
    </div>

    <div class="callout reveal delay-4" style="border-left-color: var(--accent4);">
      <strong>The optimizer.</strong> When the model figures out it was wrong, it needs to decide <em>how much</em> to adjust each number. A simple approach would just push numbers in the right direction. Adam (the optimizer used here) is smarter: it remembers which direction things have been moving and adjusts its step size accordingly. Think of it like a ball rolling downhill that builds up momentum. Karpathy calls it "the blessed optimizer." The learning rate also slows down over time, like easing off the gas as you get close to your destination.
    </div>
  </div>
</section>

<!-- ===================== CH6: INFERENCE ===================== -->
<section class="chapter" id="ch6">
  <div class="col-wide">
    <div class="chapter-label reveal">06 &mdash; Inference</div>
    <h2 class="reveal delay-1">The model<br><span class="highlight">speaks</span></h2>
    <p class="lead reveal delay-2">
      Once trained, the model can invent new names. You give it the start marker, it guesses the most likely first letter. You feed that letter back in, it guesses the second letter. Keep going until it decides the name is done. Temperature is a dial: turn it down and the model plays it safe with common names, turn it up and it gets creative (and weird).
    </p>

    <div class="demo-box reveal delay-3" id="inferDemo">
      <h4>Token Probability</h4>
      <p style="font-size:0.8em;color:var(--text-dim);margin-bottom:8px;">
        Given the letters so far, the model assigns a likelihood to every possible next letter. Drag the temperature slider to see how it changes which letters the model would pick.
      </p>
      <div class="temp-control">
        <span>Temperature:</span>
        <input type="range" id="tempSlider" min="0.1" max="2.0" step="0.1" value="0.5">
        <span class="val" id="tempVal">0.5</span>
      </div>
      <div style="font-family:var(--mono);font-size:0.85em;color:var(--text-dim);margin-bottom:12px;">
        Context: <span id="inferContext" style="color:var(--accent);">BOS → j → o → h</span>
      </div>
      <div class="token-probs" id="tokenProbs"></div>
      <div style="margin-top:12px;text-align:center;">
        <button onclick="randomizeInference()" style="background:var(--bg-interactive);border:1px solid var(--border);color:var(--accent);padding:6px 20px;border-radius:8px;cursor:pointer;font-family:var(--font);font-size:12px;">New context</button>
      </div>
    </div>

    <div class="callout reveal delay-4" style="border-left-color: var(--accent);">
      <strong>This is exactly how ChatGPT works.</strong> Same loop: predict the next piece, pick one, feed it back in. The only differences are size (billions of numbers instead of thousands), vocabulary (word chunks instead of single letters), and memory (it can look at 128,000+ tokens instead of 8). But the core process of "guess the next one, then repeat" is identical.
    </div>
  </div>
</section>

<!-- ===================== FOOTER ===================== -->
<div class="footer">
  <p>Original code by <a href="https://karpathy.ai" target="_blank">Andrej Karpathy</a> &middot; Explainer by Hardy Thomas &middot; Built with Claude</p>
</div>

<!-- ===================== JAVASCRIPT ===================== -->
<script>
// ============ SCROLL & REVEAL ============
const chapters = document.querySelectorAll('.chapter');
const dots = document.querySelectorAll('.nav-dot');
const progressBar = document.getElementById('progressBar');

function scrollToChapter(i) {
  chapters[i].scrollIntoView({ behavior: 'smooth' });
}

const revealObs = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
}, { threshold: 0.1 });
document.querySelectorAll('.reveal').forEach(el => revealObs.observe(el));

window.addEventListener('scroll', () => {
  const scrollY = window.scrollY;
  const docH = document.documentElement.scrollHeight - window.innerHeight;
  progressBar.style.width = (scrollY / docH * 100) + '%';

  let active = 0;
  chapters.forEach((ch, i) => {
    const rect = ch.getBoundingClientRect();
    if (rect.top < window.innerHeight * 0.5) active = i;
  });
  dots.forEach((d, i) => d.classList.toggle('active', i === active));
});

// ============ TOKENIZER DEMO ============
const CHARS = 'abcdefghijklmnopqrstuvwxyz'.split('');
const BOS_ID = CHARS.length;
const COLORS_TOK = [
  '#f0a848','#e85d9a','#7deba0','#8cb4ff','#ffa657','#d4a0e8',
  '#ff7b6b','#b08fd8','#44cc88','#ffaa44','#e8c560','#7ee787',
];

function updateTokenizer() {
  const input = document.getElementById('tokInput').value.toLowerCase().replace(/[^a-z]/g, '');
  const output = document.getElementById('tokOutput');
  const seq = document.getElementById('tokSequence');

  let html = '<div style="display:flex;align-items:center;gap:4px;"><span style="background:var(--bg-interactive);border:1px solid var(--border);padding:6px 10px;border-radius:8px;font-family:var(--mono);font-size:0.9em;color:var(--accent3);">BOS</span>';
  const ids = [BOS_ID];

  for (const ch of input) {
    const idx = CHARS.indexOf(ch);
    if (idx >= 0) {
      const color = COLORS_TOK[idx % COLORS_TOK.length];
      html += `<span style="font-size:1.2em;color:var(--text-dim);">&rarr;</span>`;
      html += `<span style="background:${color}22;border:1px solid ${color}44;padding:6px 10px;border-radius:8px;font-family:var(--mono);font-size:0.9em;color:${color};">${ch}<span style="font-size:0.6em;opacity:0.6;margin-left:4px;">${idx}</span></span>`;
      ids.push(idx);
    }
  }
  html += `<span style="font-size:1.2em;color:var(--text-dim);">&rarr;</span>`;
  html += `<span style="background:var(--bg-interactive);border:1px solid var(--border);padding:6px 10px;border-radius:8px;font-family:var(--mono);font-size:0.9em;color:var(--accent3);">BOS</span>`;
  ids.push(BOS_ID);
  html += '</div>';

  output.innerHTML = html;
  seq.textContent = `Token IDs: [${ids.join(', ')}]`;
}

document.getElementById('tokInput').addEventListener('input', updateTokenizer);
updateTokenizer();

// ============ AUTOGRAD DEMO ============
function runAutograd(mode) {
  const canvas = document.getElementById('compCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.parentElement.clientWidth;
  const H = canvas.parentElement.clientHeight;
  canvas.width = W; canvas.height = H;

  ctx.clearRect(0, 0, W, H);

  // Simple computation: loss = -(x * w + b).log()
  const nodes = [
    { label: 'x=2.0', x: 60, y: 60, val: 2.0, grad: null },
    { label: 'w=0.5', x: 60, y: 180, val: 0.5, grad: null },
    { label: 'b=0.1', x: 60, y: H - 60, val: 0.1, grad: null },
    { label: 'x*w', x: W*0.3, y: 120, val: 1.0, grad: null },
    { label: '+b', x: W*0.5, y: 150, val: 1.1, grad: null },
    { label: 'log', x: W*0.7, y: 150, val: 0.0953, grad: null },
    { label: '-loss', x: W-60, y: 150, val: -0.0953, grad: null },
  ];
  const edges = [
    [0, 3], [1, 3], [3, 4], [2, 4], [4, 5], [5, 6]
  ];

  if (mode === 'backward') {
    nodes[6].grad = 1.0;
    nodes[5].grad = -1.0;
    nodes[4].grad = -1.0 / 1.1;
    nodes[3].grad = nodes[4].grad;
    nodes[2].grad = nodes[4].grad;
    nodes[0].grad = nodes[3].grad * 0.5;
    nodes[1].grad = nodes[3].grad * 2.0;
  }

  // Draw edges
  for (const [a, b] of edges) {
    ctx.beginPath();
    ctx.moveTo(nodes[a].x, nodes[a].y);
    ctx.lineTo(nodes[b].x, nodes[b].y);
    if (mode === 'backward') {
      ctx.strokeStyle = '#e85d9a55';
      ctx.lineWidth = 2;
    } else if (mode === 'forward') {
      ctx.strokeStyle = '#f0a84855';
      ctx.lineWidth = 2;
    } else {
      ctx.strokeStyle = '#2a243566';
      ctx.lineWidth = 1;
    }
    ctx.stroke();

    // Arrow
    const dx = nodes[b].x - nodes[a].x, dy = nodes[b].y - nodes[a].y;
    const len = Math.hypot(dx, dy);
    const mx = (nodes[a].x + nodes[b].x) / 2, my = (nodes[a].y + nodes[b].y) / 2;
    const angle = Math.atan2(dy, dx);
    if (mode === 'backward') {
      // Backward arrow (reversed)
      ctx.fillStyle = '#e85d9a';
      ctx.save(); ctx.translate(mx, my); ctx.rotate(angle + Math.PI);
      ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(-3, -4); ctx.lineTo(-3, 4); ctx.fill();
      ctx.restore();
    } else if (mode === 'forward') {
      ctx.fillStyle = '#f0a848';
      ctx.save(); ctx.translate(mx, my); ctx.rotate(angle);
      ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(-3, -4); ctx.lineTo(-3, 4); ctx.fill();
      ctx.restore();
    }
  }

  // Draw nodes
  for (const n of nodes) {
    const r = 28;
    ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
    ctx.fillStyle = '#16131c';
    ctx.strokeStyle = mode === 'backward' && n.grad !== null ? '#e85d9a' :
                     mode === 'forward' ? '#f0a848' : '#2a2435';
    ctx.lineWidth = 2;
    ctx.fill(); ctx.stroke();

    ctx.font = '10px "JetBrains Mono", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#f0ece4';
    ctx.fillText(n.label, n.x, n.y + 3);

    if (mode === 'forward') {
      ctx.font = '9px "JetBrains Mono", monospace';
      ctx.fillStyle = '#f0a848';
      ctx.fillText(n.val.toFixed(3), n.x, n.y + 16);
    }
    if (mode === 'backward' && n.grad !== null) {
      ctx.font = '9px "JetBrains Mono", monospace';
      ctx.fillStyle = '#e85d9a';
      ctx.fillText('∇' + n.grad.toFixed(3), n.x, n.y - 34);
    }
  }
}
// Init
setTimeout(() => runAutograd('reset'), 100);

// ============ ATTENTION DEMO ============
const ATTN_WORD = 'john';
let attnHead = 0;
let attnWeights = [];

function generateAttnWeights() {
  attnWeights = [];
  for (let h = 0; h < 4; h++) {
    const hw = [];
    for (let i = 0; i < ATTN_WORD.length; i++) {
      const row = [];
      let sum = 0;
      for (let j = 0; j <= i; j++) {
        const v = Math.random() * 2 + (j === i ? 1 : 0) + (j === 0 ? 0.5 : 0);
        row.push(v);
        sum += v;
      }
      // Softmax
      const exps = row.map(v => Math.exp(v));
      const total = exps.reduce((a, b) => a + b, 0);
      hw.push(exps.map(v => v / total));
    }
    attnWeights.push(hw);
  }
}
generateAttnWeights();

function renderAttn() {
  const grid = document.getElementById('attnGrid');
  const labelsTop = document.getElementById('attnLabelsTop');
  const labelsLeft = document.getElementById('attnLabelsLeft');
  const n = ATTN_WORD.length;

  grid.style.gridTemplateColumns = `repeat(${n}, 36px)`;
  grid.innerHTML = '';
  labelsTop.innerHTML = '';
  labelsLeft.innerHTML = '';

  // Offset for left labels
  labelsTop.style.paddingLeft = '38px';

  for (let j = 0; j < n; j++) {
    labelsTop.innerHTML += `<span class="attn-label">${ATTN_WORD[j]}</span>`;
  }
  for (let i = 0; i < n; i++) {
    labelsLeft.innerHTML += `<div style="height:36px;display:flex;align-items:center;font-family:var(--mono);font-size:10px;color:var(--text-dim);width:36px;justify-content:center;">${ATTN_WORD[i]}</div>`;
  }

  const hw = attnWeights[attnHead];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const cell = document.createElement('div');
      cell.className = 'attn-cell';
      if (j <= i) {
        const w = hw[i][j];
        const intensity = Math.floor(w * 255);
        cell.style.background = `rgba(240, 168, 72, ${w * 0.9 + 0.1})`;
        cell.textContent = (w * 100).toFixed(0);
        cell.style.color = w > 0.4 ? '#0c0a0f' : '#f0ece4';
      } else {
        cell.style.background = '#0c0a0f80';
        cell.textContent = '';
      }
      grid.appendChild(cell);
    }
  }

  // Highlight active head button
  document.querySelectorAll('.attn-head-btn').forEach(b => {
    b.style.borderColor = parseInt(b.dataset.h) === attnHead ? 'var(--accent)' : 'var(--border)';
    b.style.color = parseInt(b.dataset.h) === attnHead ? 'var(--accent)' : 'var(--text-secondary)';
  });
}

function setAttnHead(h) { attnHead = h; renderAttn(); }
function randomizeAttn() { generateAttnWeights(); renderAttn(); }
renderAttn();

// ============ TRAINING LOSS DEMO ============
let trainAnimId = null;
let trainStep = 0;
let lossHistory = [];

function drawLoss() {
  const canvas = document.getElementById('lossCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.parentElement.clientWidth;
  const H = canvas.parentElement.clientHeight;
  canvas.width = W; canvas.height = H;

  ctx.clearRect(0, 0, W, H);

  if (lossHistory.length < 2) return;

  // Grid
  ctx.strokeStyle = '#2a243533';
  ctx.lineWidth = 0.5;
  for (let y = 0; y < H; y += H/5) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Loss curve
  const maxLoss = 4.0;
  const minLoss = 0;
  ctx.beginPath();
  for (let i = 0; i < lossHistory.length; i++) {
    const x = (i / 500) * W;
    const y = H - ((lossHistory[i] - minLoss) / (maxLoss - minLoss)) * H;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.strokeStyle = '#f0a848';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Glow
  ctx.lineTo((lossHistory.length - 1) / 500 * W, H);
  ctx.lineTo(0, H);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, 'rgba(240,168,72,0.15)');
  grad.addColorStop(1, 'rgba(240,168,72,0)');
  ctx.fillStyle = grad;
  ctx.fill();

  // Labels
  ctx.font = '10px "JetBrains Mono", monospace';
  ctx.fillStyle = '#5a5264';
  ctx.fillText(`Step ${trainStep}/500`, 10, 16);
  if (lossHistory.length > 0) {
    ctx.fillText(`Loss: ${lossHistory[lossHistory.length - 1].toFixed(3)}`, 10, 30);
  }
}

function startTraining() {
  if (trainAnimId) { cancelAnimationFrame(trainAnimId); trainAnimId = null; }
  trainStep = 0;
  lossHistory = [];

  // Simulate a realistic loss curve
  function step() {
    if (trainStep >= 500) {
      document.getElementById('trainStatus').textContent = 'Done!';
      document.getElementById('trainStatus').style.color = 'var(--accent3)';
      trainAnimId = null;
      return;
    }

    // Simulated loss: starts ~3.3, decays to ~2.0 with noise
    const t = trainStep / 500;
    const baseLoss = 3.3 * Math.exp(-3 * t) + 2.0 + 0.3 * Math.exp(-8 * t);
    const noise = (Math.random() - 0.5) * 0.4 * Math.exp(-2 * t);
    const lr_cos = 0.5 * (1 + Math.cos(Math.PI * t));
    lossHistory.push(Math.max(1.5, baseLoss + noise));

    trainStep++;
    document.getElementById('trainStatus').textContent = `Step ${trainStep}/500  Loss: ${lossHistory[lossHistory.length-1].toFixed(3)}  LR: ${(0.01 * lr_cos).toFixed(4)}`;
    document.getElementById('trainStatus').style.color = 'var(--accent4)';
    drawLoss();

    trainAnimId = requestAnimationFrame(step);
  }
  step();
}

drawLoss();

// ============ INFERENCE / TOKEN PROB DEMO ============
const SAMPLE_CONTEXTS = [
  { chars: ['j','o','h'], next: [{c:'n',p:0.42},{c:'a',p:0.18},{c:'e',p:0.12},{c:'s',p:0.08},{c:'i',p:0.06},{c:'BOS',p:0.04}] },
  { chars: ['m','a','r'], next: [{c:'y',p:0.35},{c:'i',p:0.22},{c:'k',p:0.15},{c:'t',p:0.08},{c:'a',p:0.06},{c:'BOS',p:0.03}] },
  { chars: ['s','a'], next: [{c:'m',p:0.28},{c:'r',p:0.22},{c:'n',p:0.16},{c:'l',p:0.11},{c:'d',p:0.07},{c:'BOS',p:0.03}] },
  { chars: ['a','l','i'], next: [{c:'c',p:0.32},{c:'s',p:0.18},{c:'n',p:0.14},{c:'a',p:0.12},{c:'BOS',p:0.08},{c:'x',p:0.04}] },
  { chars: ['h','a','r','d'], next: [{c:'y',p:0.38},{c:'i',p:0.20},{c:'e',p:0.14},{c:'BOS',p:0.10},{c:'o',p:0.06},{c:'a',p:0.04}] },
];
let currentContext = 0;

function renderInference() {
  const ctx = SAMPLE_CONTEXTS[currentContext];
  const temp = parseFloat(document.getElementById('tempSlider').value);
  document.getElementById('tempVal').textContent = temp.toFixed(1);

  const contextStr = 'BOS → ' + ctx.chars.join(' → ');
  document.getElementById('inferContext').textContent = contextStr;

  // Apply temperature to probabilities
  const logits = ctx.next.map(n => Math.log(n.p + 0.001));
  const scaled = logits.map(l => l / temp);
  const maxL = Math.max(...scaled);
  const exps = scaled.map(l => Math.exp(l - maxL));
  const sum = exps.reduce((a, b) => a + b, 0);
  const probs = exps.map(e => e / sum);

  const container = document.getElementById('tokenProbs');
  let html = '';
  const maxP = Math.max(...probs);
  for (let i = 0; i < ctx.next.length; i++) {
    const p = probs[i];
    const pct = (p / maxP * 100).toFixed(0);
    const label = ctx.next[i].c === 'BOS' ? '<span style="color:var(--accent3)">END</span>' : ctx.next[i].c;
    html += `<div class="token-prob-row">
      <div class="token-prob-char">${label}</div>
      <div class="token-prob-bar-wrap"><div class="token-prob-bar" style="width:${pct}%"></div></div>
      <div class="token-prob-val">${(p*100).toFixed(1)}%</div>
    </div>`;
  }
  container.innerHTML = html;
}

function randomizeInference() {
  currentContext = (currentContext + 1) % SAMPLE_CONTEXTS.length;
  renderInference();
}

document.getElementById('tempSlider').addEventListener('input', renderInference);
renderInference();

// ============ RESIZE HANDLERS ============
window.addEventListener('resize', () => {
  if (document.getElementById('compCanvas').parentElement.clientWidth > 0) {
    // Re-render autograd if visible
  }
  if (lossHistory.length > 0) drawLoss();
});
</script>

</body>
</html>
